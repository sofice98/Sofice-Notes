# 概述

Go语言在多核并发上拥有原生的设计优势，Go语言从底层原生支持并发，无须第三方库、开发者的编程技巧和开发经验。Go语言的并发是基于 `goroutine` 的，`goroutine` 类似于线程，但并非线程。可以将 `goroutine` 理解为一种虚拟线程。Go 语言运行时会参与调度 `goroutine`，并将 `goroutine` 合理地分配到每个 CPU 中，最大限度地使用CPU性能。开启一个goroutine的消耗非常小（大约2KB的内存），你可以轻松创建数百万个`goroutine`。

`goroutine`的特点：

- `goroutine`具有可增长的分段堆栈。这意味着它们只在需要时才会使用更多内存。
- `goroutine`的启动时间比线程快。
- `goroutine`原生支持利用channel安全地进行通信。
- `goroutine`共享数据结构时无需使用互斥锁。

## 环境变量

```
GOROOT: go源码的目录
GOPATH: go项目目录
PATH:   %GOROOT%/bin
```



## 目录结构（不使用Go Module）

使用传统的GOPATH方式管理目录。它将会在`vendor`目录下和`GOPATH`目录中查找依赖包。也把这种模式叫`GOPATH模式`。

```
go env -w GO111MODULE=off
```

![GO目录结构](http://mdimg.sofice.top/202201181952370.png)

举个例子：张三和李四都有一个名叫studygo的项目，那么这两个包的路径就会是：

```go
import "github.com/zhangsan/studygo"
```

和

```go
import "github.com/lisi/studygo"
```

以后我们从`github`上下载别人包的时候，如：

```go
go get github.com/jmoiron/sqlx
```

那么，这个包会下载到我们本地`GOPATH`目录下的`src/github.com/jmoiron/sqlx`。

**适合企业开发者**

<img src="http://mdimg.sofice.top/202201182011600.png" alt="GO目录结构" style="zoom: 43%;" />



**import 下划线：**只使用init函数，不全部导入。`import _ "./hello"`



## Go Module

使用`modules`功能，而不会访问`GOPATH`，也把这种模式称作`module-aware`模式。这种模式下，`GOPATH`不再在`build`时扮演导入的角色，但是尽管如此，它还是承担着存储下载依赖包的角色。它会将依赖包放在`GOPATH/pkg/mod`目录下。

module是一个相关Go包的集合，它是源代码更替和版本控制的单元。模块由源文件形成的go.mod文件的根目录定义，包含go.mod文件的目录也被称为模块根。moudles取代旧的的基于GOPATH方法来指定在工程中使用哪些源文件或导入包。模块路径是导入包的路径前缀，go.mod文件定义模块路径，并且列出了在项目构建过程中使用的特定版本。

```sh
go env -w GO111MODULE=on
```

**go.mod文件**

go.mod文件定义module路径以及列出其他需要在build时引入的模块的特定的版本。例如下面的例子中，go.mod声明example.com/m路径时module的根目录，同时也声明了module依赖特定版本的golang.org/x/text和gopkg.in/yaml.v2。

```
module example.com/foobar

go 1.17

require (
    example.com/apple v0.1.2
    example.com/banana v1.2.3
    example.com/banana/v2 v2.3.4
    example.com/pineapple v0.0.0-20190924185754-1b0db40df49a
)

exclude example.com/banana v1.2.4
replace example.com/apple v0.1.2 => example.com/rda v0.1.0 
replace example.com/banana => example.com/hugebanana
```

目前有以下 5 个动词:

- module：用于定义当前项目的模块路径。
- go：用于设置预期的 Go 版本。
- require：用于设置一个特定的模块版本。
- exclude：用于从使用中排除一个特定的模块版本。
- replace：用于将一个模块版本替换为另外一个模块版本。



**go.sum**

go.sum 是类似于比如 dep 的 Gopkg.lock 的一类文件，它详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。

一个模块路径可能有如下两种：

```
example.com/apple v0.1.2 h1:WXkYYl6Yr3qBf1K79EBnL4mak0OimBfB0XUf9Vl28OQ= 
example.com/apple v0.1.2/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
```

前者为 Go modules 打包整个模块包文件 zip 后再进行 hash 值，而后者为针对 go.mod 的 hash 值。他们两者，要不就是同时存在，要不就是只存在 go.mod hash。

那什么情况下会不存在 zip hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 zip hash，就会出现不存在 zip hash，只存在 go.mod hash 的情况。



**go mod命令**

Go mod提供了一系列操作modules的命令，记住，所有的go命令中现在已经内置了对module的支持，而不仅仅是go mod命令。例如使用go get时，会经常自动在后台添加、移除、升级、降级依赖包版本。
命令语法：go mod \<command> [arguments]。Go mod提供的命令有下面几个，对于比较常用的命令进行详细说明。

```sh
init         //在当前目录下初始化新的模块
tidy         //添加缺失的模块以及移除无用的模块，生成go.sum文件
verify       //验证依赖项是否达到预期的目的
vendor		 //生成vendor文件夹
download     //下载模块到本地缓存，具体可以通过命令go env查看，其中环境变量GOCACHE就是缓存的地址，如果该文件夹的内容太大，可以通过命令go clean -cache
edit         //从工具或脚本中编辑go.mod文件
graph        //打印模块需求图
why          //解释为什么需要包或模块
```

1. 执行命令go mod init在当前目录下生成一个go.mod文件，执行这条命令时，当前目录不能存在go.mod文件。如果之前生成过，要先删除；
2. 如果你工程中存在一些不能确定版本的包，那么生成的go.mod文件可能就不完整，因此继续执行下面的命令；
3. 执行go mod tidy命令，它会添加缺失的模块以及移除不需要的模块。执行后会生成go.sum文件(模块下载条目)。添加参数-v，例如go mod tidy -v可以将执行的信息，即删除和添加的包打印到命令行；
4. 执行命令go mod verify来检查当前模块的依赖是否全部下载下来，是否下载下来被修改过。如果所有的模块都没有被修改过，那么执行这条命令之后，会打印all modules verified。
5. 执行命令go mod  vendor生成vendor文件夹，该文件夹下将会放置你go.mod文件描述的依赖包，文件夹下同时还有一个文件modules.txt，它是你整个工程的所有模块。在执行这条命令之前，如果你工程之前有vendor目录，应该先进行删除。同理go mod vendor -v会将添加到vendor中的模块打印出来；



## Go 命令行

1. **go build**

   go build 命令主要是用于测试编译。在包的编译过程中，若有必要，会同时编译与之相关联的包。

   - 如果是普通包，当你执行go build命令后，不会产生任何文件。

   - 如果是main包，当只执行go build命令后，会在当前目录下生成一个可执行文件。如果需要在 `$GOPATH/bin` 下生成相应的exe文件，需要执行go install 或者使用 `go build -o 路径/a.exe`。

   - 如果某个文件夹下有多个文件，而你只想编译其中某一个文件，可以在 go build 之后加上文件名，例如 go build a.go；go build 命令默认会编译当前目录下的所有go文件。

   - 你也可以指定编译输出的文件名。比如，我们可以指定go build -o myapp.exe，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。

   - go build 会忽略目录下以”_”或者”.”开头的go文件。

   - 如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。例如有一个读取数组的程序，它对于不同的操作系统可能有如下几个源文件：

       ```
       array_linux.go 
       array_darwin.go 
       array_windows.go 
       array_freebsd.go
       ```

2. **go clean**

   go clean 命令是用来移除当前源码包里面编译生成的文件，这些文件包括

       _obj/ 旧的object目录，由Makefiles遗留
       _test/ 旧的test目录，由Makefiles遗留
       _testmain.go 旧的gotest文件，由Makefiles遗留
       test.out 旧的test记录，由Makefiles遗留
       build.out 旧的test记录，由Makefiles遗留
       *.[568ao] object文件，由Makefiles遗留
       DIR(.exe) 由 go build 产生
       DIR.test(.exe) 由 go test -c 产生
       MAINFILE(.exe) 由 go build MAINFILE.go产生

3. **go fmt**

   go fmt 命令主要是用来帮你格式化所写好的代码文件。

   比如我们写了一个格式很糟糕的 test.go 文件，我们只需要使用 fmt go test.go 命令，就可以让go帮我们格式化我们的代码文件。但是我们一般很少使用这个命令，因为我们的开发工具一般都带有保存时自动格式化功能，这个功能底层其实就是调用了 go fmt 命令而已。

   使用go fmt命令，更多时候是用gofmt，而且需要参数-w，否则格式化结果不会写入文件。gofmt -w src，可以格式化整个项目。

4. **go get**

   go get 命令主要是用来动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。这个命令在内部实际上分成了两步操作：第一步是通过源码工具clone代码到 `$GOPATH/pkg/mod` 目录（不使用GoModule： `$GOPATH/src` ），第二步是执行go install。下载源码包的go工具会自动根据不同的域名调用不同的源码工具，对应关系如下：

       BitBucket (Mercurial Git)
       GitHub (Git)
       Google Code Project Hosting (Git, Mercurial, Subversion)
       Launchpad (Bazaar)

   所以为了go get 能正常工作，你必须确保安装了合适的源码管理工具，并同时把这些命令加入你的PATH中。其实go get支持自定义域名的功能，具体参见go help remote。

5. **go install**

   go install 命令在内部实际上分成了两步操作：第一步是生成结果文件（可执行文件或者.a包），第二步会把编译好的结果移到 `$GOPATH/pkg` 或者 `$GOPATH/bin`。

   .exe文件： 一般是 go install 带main函数的go文件产生的，有函数入口，所有可以直接运行。

   .a应用包： 一般是 go install 不包含main函数的go文件产生的，没有函数入口，只能被调用。

6. **go test**

   go test 命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。输出的信息类似

7. **go run** 

   编译放到临时文件夹下，并运行exe





# 变量 & 常量 var & const

```go
// 声明
var 变量名 变量类型
// 批量声明
var (
    a string
    b int
    c bool
    d float32
)
// 类型推导
var name = "pprof.cn"
// 短变量声明，局部变量
n := 10
// 匿名变量，不占用内存
x, _ := foo()

// 常量计数器，自动自增，简化代码
const (
    n1 = iota //0
    n2        //1
    n3        //2
    n4        //3
)
```

**可见性**：

1. 声明在函数内部，是函数的本地值，类似private
2. 声明在函数外部，是对当前包可见(包内所有.go文件都可见)的全局值，类似protect
3. 声明在函数外部且首字母大写是所有包可见的全局值，类似public

声明方式：var（声明变量）, const（声明常量）, type（声明类型） ,func（声明函数）

## 内置类型

Golang 更明确的数字类型命名，支持 Unicode，支持常用数据结构。只有三个引用类型，其余为值类型

| 类型          | 长度(字节) | 默认值 | 说明                                      |
| ------------- | ---------- | ------ | ----------------------------------------- |
| bool          | 1          | false  |                                           |
| byte          | 1          | 0      | uint8                                     |
| rune          | 4          | 0      | Unicode Code Point, int32                 |
| int, uint     | 4或8       | 0      | 32 或 64 位                               |
| int8, uint8   | 1          | 0      | -128 ~ 127, 0 ~ 255，byte是uint8 的别名   |
| int16, uint16 | 2          | 0      | -32768 ~ 32767, 0 ~ 65535                 |
| int32, uint32 | 4          | 0      | -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名 |
| int64, uint64 | 8          | 0      |                                           |
| float32       | 4          | 0.0    |                                           |
| float64       | 8          | 0.0    |                                           |
| complex64     | 8          |        |                                           |
| complex128    | 16         |        |                                           |
| uintptr       | 4或8       |        | 以存储指针的 uint32 或 uint64 整数        |
| array         |            |        | 值类型                                    |
| struct        |            |        | 值类型                                    |
| string        |            | ""     | UTF-8 字符串                              |
| slice         |            | nil    | 引用类型                                  |
| map           |            | nil    | 引用类型                                  |
| channel       |            | nil    | 引用类型                                  |
| interface     |            | nil    | 接口                                      |
| function      |            | nil    | 函数                                      |

支持八进制、 六进制，以及科学记数法。标准库 math 定义了各数字类型取值范围。

```go
a, b, c, d := 071, 0x1F, 1e9, math.MinInt16
```

**空指针值 nil**。



## 内置函数

```
append          -- 用来追加元素到数组、slice中,返回修改后的数组、slice
close           -- 主要用来关闭channel
delete            -- 从map中删除key对应的value
panic            -- 停止常规的goroutine  （panic和recover：用来做错误处理）
recover         -- 允许程序定义goroutine的panic动作
real            -- 返回complex的实部   （complex、real imag：用于创建和操作复数）
imag            -- 返回complex的虚部
make            -- 用来分配内存，返回Type本身(只能应用于slice, map, channel)
new                -- 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针
cap                -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）
copy            -- 用于复制和连接slice，返回复制的数目
len                -- 来求长度，比如string、array、slice、map、channel ，返回长度
print、println     -- 底层打印函数，在部署环境中建议使用 fmt 包
```



## 内置接口

```go
type error interface { //只要实现了Error()函数，返回值为String的都实现了err接口
	Error()    String
}
```



## 类型转换

Go语言中只有强制类型转换，没有隐式类型转换。

```go
s1 := "hello"
byteS1 := []byte(s1)
```



# 流程控制

**for 循环**

```go
for n > 0 {                // 替代 while (n > 0) {}
    println(s[n])        // 替代 for (; n > 0;) {}
    n-- 
}

for {                    // 替代 while (true) {}
    println(s)            // 替代 for (;;) {}
}

for i, n := 0, length(s); i < n; i++ {     // 避免多次调用 length 函数。
    println(i, s[i])
} 

for n-- > 0 {} 			// 没有语句的循环
```

**for range 循环**

:star:**注意！range 会复制对象**。建议改用引用类型（&slice[index]），其底层数据不会被复制。

```go
func main() {
    slice := []int{10, 20, 30, 40}
    for index, value := range slice {
        fmt.Printf("value = %d , value-addr = %x , slice-addr = %x\n", value, &value, &slice[index])
    }
}
// 输出
value = 10 , value-addr = c4200aedf8 , slice-addr = c4200b0320
value = 20 , value-addr = c4200aedf8 , slice-addr = c4200b0328
value = 30 , value-addr = c4200aedf8 , slice-addr = c4200b0330
value = 40 , value-addr = c4200aedf8 , slice-addr = c4200b0338
```

for range可以遍历key为string类型的map并同时获取key和value；遍历channel

```go
for key, value := range oldMap {
    newMap[key] = value
}
```

|             | 1st value | 2nd value | 备注          |
| ----------- | --------- | --------- | ------------- |
| string      | index     | s[index]  | unicode, rune |
| array/slice | index     | s[index]  |               |
| map         | key       | m[key]    |               |
| channel     | element   |           |               |

**三目运算符**：不支持三元操作符

**if 分支**：

```go
if n := "abc"; x > 0 {     // 初始化语句未必就是定义变量， 如 println("init") 也是可以的。
    println(n[2])
} else if x < 0 {    // 注意 else if 和 else 左大括号位置。
    println(n[1])
} else {
    println(n[0])
}
```

**select 语句**：类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行**（用于通道多路复用）**。一个默认的子句应该总是可运行的。



# 字符串 string

字符串的内部实现使用UTF-8编码，底层是一个byte数组，所以可以和 []byte 类型相互转换。

Go 语言的字符有以下两种：

- uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。
- rune类型，代表一个 UTF-8字符。

```go
// 遍历字符串
func traversalString() {
    s := "pprof.cn博客"
    for i := 0; i < len(s); i++ { //byte
        fmt.Printf("%v(%c) ", s[i], s[i])
    }
    fmt.Println()
    for _, r := range s { //rune
        fmt.Printf("%v(%c) ", r, r)
    }
    fmt.Println()
}
// 输出
112(p) 112(p) 114(r) 111(o) 102(f) 46(.) 99(c) 110(n) 229(å) 141() 154() 229(å) 174(®) 162(¢)
112(p) 112(p) 114(r) 111(o) 102(f) 46(.) 99(c) 110(n) 21338(博) 23458(客)
```

要修改字符串，需要先将其转换成`[]rune或[]byte`，完成后再转换为`string`。无论哪种转换，都会重新分配内存，并复制字节数组。

```go
func changeString() {
    s1 := "hello"
    // 强制类型转换
    byteS1 := []byte(s1)
    byteS1[0] = 'H'
    fmt.Println(string(byteS1))

    s2 := "博客"
    runeS2 := []rune(s2)
    runeS2[0] = '狗'
    fmt.Println(string(runeS2))
}
```



# 数组 array

长度是数组类型的一部分，因此，var a[5] int和var a[10]int是不同的类型。

```go
// 初始化
var arr [3]
a := [3]int{1, 2}           // 未初始化元素值为 0。
b := [...]int{1, 2, 3, 4}   // 通过初始化值确定数组长度。第 2 纬度不能用
c := [5]int{2: 100, 4: 200} // 使用索引号初始化元素。
d := [...]struct {
    name string
    age  uint8
}{
    {"user1", 10}, // 可省略元素类型。
    {"user2", 20}, // 别忘了最后一行的逗号。
}

// 遍历
for i := 0; i < len(a); i++ {
}
for index, v := range a {
}

// 指针
p := &s[2] // *int, 获取底层数组元素指针。
*p += 100
var p1 *[5]int // 数组指针
var p2 [5]*int // 指针数组
```



# 切片 slice

切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。

切片的长度可以改变，因此，切片是一个可变的数组。

切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。 

cap=len(array)，是slice最大扩张容量，不能超出数组限制。0 <= len <= cap，其中array是slice引用的数组。

如果 slice == nil，那么 len、cap 结果都等于 0。

```go
全局：
var arr = [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} // 数组
var slice0 []int = arr[start:end]       
var slice1 []int = arr[start:end:max] // cap=max-start 
局部：
slice2 := arr[start:end]
slice  := make([]type, len)
slice  := make([]type, len, cap)
```

**append ：**向 slice 尾部添加数据，返回新的 slice 对象。

```go
s2 := append(s1, 1)
c := append(a, b...)
```

:star: 数组的切片扩容后，数组也不能超过原长度访问。

**copy ：**函数 copy 在两个 slice 间复制数据，复制长度以 len 小的为准。两个 slice 可指向同一底层数组，允许元素区间重叠。

```go
data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
s1 := data[8:] // [8 9]
s2 := data[:5] // [0 1 2 3 4]
copy(s2, s1) // s1 : [8 9]  s2 : [8 9 2 3 4]  data :  [8 9 2 3 4 5 6 7 8 9]
```

:star: 向二维切片中添加一维切片拷贝

```go
tmp := make([]int, len(*nums))
copy(tmp, *nums)
*res = append(*res,tmp)
```

**string**：底层就是一个byte的数组，因此，也可以进行切片操作。

```go
str := "hello world"
s1 := str[0:5]
// string本身是不可变的。因此要改变string中字符，需要如下操作：
str := "Hello world"
s := []byte(str) //中文字符需要用[]rune(str)
s[6] = 'G'
s = s[:8]
s = append(s, '!')
str = string(s)
```



## 底层结构

读写操作实际目标是底层数组，但**自身是结构体**，值拷贝传递。

```go
type slice struct {
    array unsafe.Pointer// 指向数组的指针
    len   int			// 切片长度
    cap   int			// 最大容量
}
```

**① 创建切片**

1. 提供len和cap创建。内存空间申请了6个 int 类型的内存大小。由于 len = 4，所以后面2个暂时访问不到，但是容量还是在的。这时候数组里面每个变量都是0 。

   <img src="http://mdimg.sofice.top/202201191452833.png" alt="img" style="zoom: 50%;" />

2. 字面量也可以创建切片。这里是用字面量创建的一个 len = 6，cap = 6 的切片，这时候数组里面每个元素的值都初始化完成了。需要注意的是 [ ] 里面不要写数组的容量，因为如果写了个数以后就是数组了，而不是切片了。

   <img src="http://mdimg.sofice.top/202201191455738.png" alt="img" style="zoom:50%;" />

3. 在现有数组基础上创建切片，arr[start: end: max]，cap=max-start 

   <img src="http://mdimg.sofice.top/202201191458645.png" alt="img" style="zoom:50%;" />

nil与空切片

- nil切片指向nil：`var slice []int`
- 空切片指向一个内存地址，但是没有分配空间：`silce := make( []int , 0 )`



**② 切片扩容**

**扩容策略**

- 如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。

- 一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。

注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。

**内存变化**

- 切片还有容量：直接在原数组上操作
- 切片无容量：重新分配新的底层数组



# 指针

区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。

空指针值为 nil

```go
// 分配空间
// new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值
a := new(int)
// make区别于new，只用于slice、map以及chan的内存创建。返回的类型就是这三个类型本身，而不是他们的指针类型
var b map[string]int
b = make(map[string]int, 10)
b["测试"] = 100
```



# Map

map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，默认初始值为nil，必须初始化才能使用。

```go
// 初始化：使用make初始化并指定容量，也可以不指定
m := make(map[int]int)
scoreMap := make(map[string]int, 8)

// 判存key：如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值
v, ok := scoreMap["张三"]

// 遍历，可省略v
// 遍历map时的元素顺序与添加键值对的顺序无关。
for k, v := range scoreMap {
    fmt.Println(k, v)
}

// 删除
delete(map, key)
```



## 底层结构

go语言把生成的哈希值一分为二，比如一个key经过哈希函数，生成的哈希值为：8423452987653321，go语言会这它拆分为84234529，和87653321。那么，前半部分就叫做高位哈希值，后半部分就叫做低位哈希值。

- 低位哈希值：是用来确定，当前的数据存在了哪个bucket（桶）
- 高位哈希值：是用来确定当前的bucket（桶）有没有所存储的数据的。



**bmap(a bucket of map)**

bucket（桶），每一个bucket最多放8个key和value，最后由一个overflow字段指向下一个bmap，注意key、value、overflow字段都不显示定义，而是通过maptype计算偏移获取的。

![在这里插入图片描述](http://mdimg.sofice.top/202201191639848.png)

bucket的三部分：

- tophash 存储的是哈希函数算出的哈希值的高八位（8个）。是用来加快索引的。因为把高八位存储起来，这样不用完整比较key就能过滤掉不符合的key，加快查询速度当一个哈希值的高8位和存储的高8位相符合，再去比较完整的key值，进而取出value。当超过8个元素需要存入某个bucket时，hmap会拓展该bucket。

- 第二部分，存储的是key 和value，就是我们传入的key和value，注意，它的底层排列方式是，key全部放在一起，value全部放在一起。当key大于128字节时，bucket的key字段存储的会是指针，指向key的实际内容；value也是一样。这样排列好处是在key和value的长度不同的时候，可以消除padding带来的空间浪费。并且每个bucket最多存放8个键值对。

  ![在这里插入图片描述](http://mdimg.sofice.top/202201191639518.png)

- 第三部分，存储的是当bucket溢出时，指向的下一个bucket的指针

**hmap(a header of map)**

hmap是map的最外层的一个数据结构，包括了map的各种基础信息、如大小、bucket。buckets这个参数，它存储的是指向buckets数组的一个指针，当bucket(桶为0时)为nil。我们可以理解为，hmap指向了一个空bucket数组，并且当bucket数组需要扩容时，它会开辟一倍的内存空间，并且会渐进式的把原数组拷贝，即用到旧数组的时候就拷贝到新数组。

![在这里插入图片描述](http://mdimg.sofice.top/202201191641527.png)

查找或者操作map时，首先key经过hash函数生成hash值，通过哈希值的低8位来判断当前数据属于哪个桶(bucket)，找到bucket以后，通过哈希值的高八位与bucket存储的高位哈希值循环比对，如果相同就比较刚才找到的底层数组的key值，如果key相同，取出value。如果高八位hash值在此bucket没有，或者有，但是key不相同，就去链表中下一个溢出bucket中查找，直到查找到链表的末尾。

go语言的map通过数组+链表的方式实现了hash表，同时分散各个桶，使用链表法+bucket内部的寻址法解决了碰撞冲突，也提高了效率。因为即使链表很长了，go会根据装载因子，去扩容整个bucket数组



**扩容**

- 当链表越来越长，bucket的扩容次数达到一定值，其实是hmap扩容的加载因数达到6.5（元素个数/bucket），hmap就会进行扩容，将原来bucket数组数量扩充一倍，产生一个新的bucket数组，也就是bmap的buckets属性指向的数组。这样hmap中的oldbuckets属性指向的就是旧bucket数组。
- 加载因数6.5，这个是经过测试才得出的合理的一个阈值。因为，加载因子越小，空间利用率就小，加载因子越大，产生冲突的几率就大。所以6.5是一个平衡的值。
- map的扩容不会立马全部复制，而是渐进式扩容，即首先开辟2倍的内存空间，创建一个新的bucket数组。只有当访问原来旧的bucket数组时，才会将旧的bucket拷贝到新的bucket数组，进行渐进式的扩容。当然旧的数据不会删除，而是去掉引用，等待gc回收。





# container

堆

```go
// 导包
"container/heap"
// 接口
type Interface interface {
    sort.Interface
    Push(x interface{}) // add x as element Len()
    Pop() interface{}   // remove and return element Len() - 1.
}
// 实现五个接口
type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}
// 使用
h := &IntHeap{2, 1, 5}
heap.Init(h)
heap.Push(h, 3)
heap.Pop(h)
```

链表

```go
// 接口
type Element struct {
    next, prev *Element  // 上一个元素和下一个元素
    list *List  // 元素所在链表
    Value interface{}  // 元素
}

type List struct {
    root Element  // 链表的根元素
    len  int      // 链表的长度
}

//  使用
list := list.New()
list.PushBack(1)
list.PushBack(2)

// 方法
type Element
    func (e *Element) Next() *Element
    func (e *Element) Prev() *Element
type List
    func New() *List
    func (l *List) Back() *Element   // 最后一个元素
    func (l *List) Front() *Element  // 第一个元素
    func (l *List) Init() *List  // 链表初始化
    func (l *List) InsertAfter(v interface{}, mark *Element) *Element // 在某个元素后插入
    func (l *List) InsertBefore(v interface{}, mark *Element) *Element  // 在某个元素前插入
    func (l *List) Len() int // 在链表长度
    func (l *List) MoveAfter(e, mark *Element)  // 把 e 元素移动到 mark 之后
    func (l *List) MoveBefore(e, mark *Element)  // 把 e 元素移动到 mark 之前
    func (l *List) MoveToBack(e *Element) // 把 e 元素移动到队列最后
    func (l *List) MoveToFront(e *Element) // 把 e 元素移动到队列最头部
    func (l *List) PushBack(v interface{}) *Element  // 在队列最后插入元素
    func (l *List) PushBackList(other *List)  // 在队列最后插入接上新队列
    func (l *List) PushFront(v interface{}) *Element  // 在队列头部插入元素
    func (l *List) PushFrontList(other *List) // 在队列头部插入接上新队列
    func (l *List) Remove(e *Element) interface{} // 删除某个元素
```





# 函数 Function

```
func 方法名(参数列表) (返回参数) {
	函数体
}
```

:star: 注意1：无论是值传递，还是引用传递，传递给函数的都是变量的副本，不过，值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。

:star: 注意2：map、slice、chan、指针、interface默认以引用的方式传递。

```go
// 引用拷贝
func printArr(arr *[5]int) *int {}
printArr(&arr1)
```

:star: 函数名大写才能被外部调用​

## 函数返回值

`"_"`标识符，用来忽略函数的某个返回值。

Go 的返回值可以被命名，并且就像在函数体开头声明的变量那样使用。

返回值的名称应当具有一定的意义，可以作为文档使用。

没有参数的 return 语句返回各个返回变量的当前值。这种用法被称作“裸”返回。

多返回值可直接作为其他函数调用实参。

```go
func calc(a, b int) (sum int, avg int) {
    sum = a + b
    avg = (a + b) / 2
    return
}
sum, avg := calc(a, b)
```

命名返回参数可被同名局部变量遮蔽，此时需要显式返回。

```go
func add(x, y int) (z int) {
    { // 不能在一个级别，引发 "z redeclared in this block" 错误。
        var z = x + y
        // return   // Error: z is shadowed during return
        return z // 必须显式返回。
    }
}
```

命名返回参数允许 defer 延迟调用通过闭包读取和修改。

```go
func add(x, y int) (z int) {
    defer func() {
        z += 100
    }()
    z = x + y
    return
}
println(add(1, 2)) 
// 结果
103
```

## 可变参数

Golang 可变参数本质上就是 slice。只能有一个，且必须是最后一个。

在参数赋值时可以不用用一个一个的赋值，可以直接传递一个数组或者切片，特别注意的是在参数后加上“…”即可。

```go
func myfunc(args ...int) {    //0个或多个参数
}

func add(a int, args…int) int {    //1个或多个参数
}
```

其中args是一个slice，我们可以通过arg[index]依次访问所有参数,通过len(arg)来判断传递参数的个数。

使用 slice 对象做变参时，必须展开：

```go
func fun(s ...int) {}

res := fun(s...)
```

**任意类型的不定参数**

函数的参数和每个参数的类型都不是固定的。

用interface{}传递任意类型数据是Go语言的惯例用法，而且interface{}是类型安全的。

```go
func myfunc(args ...interface{}) {
}
```



## 匿名函数

```go
getSqrt := func(a float64) float64 {
    return math.Sqrt(a)
}
fmt.Println(getSqrt(4))
```

Golang匿名函数可赋值给变量，做为结构字段，或者在 channel 里传送。

```go
package main

func main() {
    // --- function variable ---
    fn := func() { println("Hello, World!") }
    fn()

    // --- function collection ---
    fns := [](func(x int) int){
        func(x int) int { return x + 1 },
        func(x int) int { return x + 2 },
    }
    println(fns[0](100))

    // --- function as field ---
    d := struct {
        fn func() string
    }{
        fn: func() string { return "Hello, World!" },
    }
    println(d.fn())

    // --- channel of function ---
    fc := make(chan func() string, 2)
    fc <- func() string { return "Hello, World!" }
    println((<-fc)())
    
    // --- go rountine ---
    go func(s string) {
        for i := 0; i < 2; i++ {
            fmt.Println(s)
        }
    }("world")
}
```



## 常用函数

```go
// 排序
sort.Strings(keys)
sort.Ints(arr)

// 自定义的结构体排序需实现 sort.Interface 接口的三个方法
type Interface interface {
    // 获取数据集合元素个数
    Len() int
    // 如果 i 索引的数据小于 j 索引的数据，返回 true，且不会调用下面的 Swap()，即数据升序排序。
    Less(i, j int) bool
    // 交换 i 和 j 索引的两个元素的位置
    Swap(i, j int)
}
sort.Sort()
sort.IsSorted()

// 随机数
rand.Seed(time.Now().Unix())
a = rand.Intn(1000)
```



## init函数 & main函数

- init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等
- 每个包可以拥有多个init函数
- 包的每个源文件也可以拥有多个init函数 
- 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)
- 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序
- init函数不能被其他函数调用，而是在main函数执行之前，自动被调用



init函数和main函数的异同：

相同点：
        两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。
不同点：
        init可以应用于任意包中，且可以重复定义多个。
        main函数只能用于main包中，且只能定义一个。



两个函数的执行顺序：

对同一个go文件的`init()`调用顺序是从上到下的。

对同一个package中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的`init()`函数。

对于不同的`package`，如果不相互依赖的话，按照main包中"先`import`的后调用"的顺序调用其包中的`init()`，如果`package`存在依赖，则先调用最早被依赖的`package`中的`init()`，最后调用`main`函数。



## 闭包

闭包是由函数及其相关引用环境组合而成的实体(即：闭包=函数+引用环境)。

当函数a()的内部函数b()被函数a()外的一个变量引用的时候，就创建了一个闭包。

闭包的作用就是在a()执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回a()所占用的资源，因为a()的内部函数b()的执行需要依赖a()中的变量i。

**闭包复制的是原对象指针**

```go
func test() func() {
	x := 100
	fmt.Printf("x (%p) = %d\n", &x, x)

	return func() {
		fmt.Printf("x (%p) = %d\n", &x, x)
	}
}

func main() {
	f := test()
	f()
    // 此时f和d不是一个实体了
	d := test()
	d()
}
// 输出
x (0xc00000a098) = 100
x (0xc00000a098) = 100
x (0xc00000a0b8) = 100
x (0xc00000a0b8) = 100
```

## 延迟调用 defer

**defer特性：**

1. 关键字 defer 用于注册延迟调用。
2. 这些调用直到 return 前才被执。因此，可以用来做资源清理。
3. 多个defer语句，按先进后出的方式执行（后面的语句会依赖前面的资源）。
4. defer语句中的变量，在defer声明时就决定了。


**defer用途：**

1. 关闭文件句柄
2. 锁资源释放
3. 数据库连接释放

go 语言的defer功能强大，对于资源管理非常方便，但是如果没用好，也会有陷阱。

**示例1：**

```go
package main

import "fmt"

func main() {
    var whatever [5]struct{}

    for i := range whatever {
        defer fmt.Println(i)
    }
}
```

输出结果：

```
    4
    3
    2
    1
    0
```

**示例2：defer 碰上闭包**

```go
package main

import "fmt"

func main() {
    var whatever [5]struct{}
    for i := range whatever {
        defer func() { fmt.Println(i) }()
    }
}
```

输出结果：

```
    4
    4
    4
    4
    4
```

> go spec：
>
> Each time a "defer" statement executes, the function value and  parameters to the call are evaluated as usualand saved anew but the  actual function is not invoked.

也就是说函数正常执行,由于闭包用到的变量 i 在执行的时候已经变成4,所以输出全都是4

**示例3**

defer后面的语句在执行的时候，函数调用的参数会被保存起来，但是不执行。也就是复制了一份。

```go
type Test struct {
    name string
}

func (t *Test) Close() {
    fmt.Println(t.name, " closed")
}
func main() {
    ts := []Test{{"a"}, {"b"}, {"c"}}
    for _, t := range ts {
        defer t.Close()
    }
}
// 输出结果
c  closed
c  closed
c  closed
```

修改后：

```go
type Test struct {
    name string
}

func (t *Test) Close() {
    fmt.Println(t.name, " closed")
}
func main() {
    ts := []Test{{"a"}, {"b"}, {"c"}}
    for _, t := range ts {
        t2 := t // 复制
        defer t2.Close()
    }
}
// 输出结果
c  closed
b  closed
a  closed
```

**示例4**

多个 defer 注册，按 FILO 次序执行 ( 先进后出 )。哪怕函数或某个延迟调用发生错误，这些调用依旧会被执行。

```go
func test(x int) {
    defer println("a")
    defer println("b")

    defer func() {
        println(100 / x) // div0 异常未被捕获，逐步往外传递，最终终止进程。
    }()

    defer println("c")
}

func main() {
    test(0)
}
// 输出结果
c
b
a
panic: runtime error: integer divide by zero
```

**延迟调用参数**

延迟调用参数在注册时求值或复制，可用指针或闭包 "延迟" 读取。

```go
func test() {
    x, y := 10, 20

    defer func(i int) {
        println("defer:", i, y) // y 闭包引用
    }(x) // x 被复制

    x += 10
    y += 100
    println("x =", x, "y =", y)
}

func main() {
    test()
}
// 输出结果
x = 20 y = 120
defer: 10 120
```

 



# 方法 Method

Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。

1. 接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。
2. 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。
3. 方法名、参数列表、返回参数：具体格式与函数定义相同。

```
func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {
	函数体
}
```

方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。

```go
func (p Person) Dream() {
    fmt.Printf("%s的梦想是学好Go语言！\n", p.name)
}
p1.Dream()
```

当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。







# 面向对象

Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。

**自定义类型**：`type MyInt int`，创建了一种新的类型

**类型别名**：` type TypeAlias = Type`，只会在代码中存在，编译自动去掉



## 结构体

```go
type person struct {
    name string
    city string
    age  int8
}
// 匿名结构体
var user struct{Name string; Age int}
// 嵌套匿名结构体
type User struct {
    address string
    Person
}

var p1 person
p1.name = "pprof.cn"
// 指针
var p2 = new(person)
var p3 = &person{}
p2.name = "测试" // 语法糖

// 初始化
p7 := &person{
    name: "pprof.cn",
    city: "北京",
    age:  18,
}
p8 := &person{
    "pprof.cn",
    "北京",
    18,
}

// 构造函数：Go语言的结构体没有构造函数，我们可以自己实现
// struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型
func newPerson(name, city string, age int8) *person {
    return &person{
        name: name,
        city: city,
        age:  age,
    }
}
```

结构体中字段大写开头public，小写表示protect（仅在定义当前结构体的包中可访问）。



```go
//JSON序列化：结构体-->JSON格式的字符串
data, err := json.Marshal(c)

//JSON反序列化：JSON格式的字符串-->结构体
str := `{"Title":"101","Students":[{"ID":0,"Gender":"男","Name":"stu00"},	  {"ID":1,"Gender":"男","Name":"stu01"},{"ID":2,"Gender":"男","Name":"stu02"},	{"ID":3,"Gender":"男","Name":"stu03"},{"ID":4,"Gender":"男","Name":"stu04"},{"ID":5,"Gender":"男","Name":"stu05"},{"ID":6,"Gender":"男","Name":"stu06"},{"ID":7,"Gender":"男","Name":"stu07"},{"ID":8,"Gender":"男","Name":"stu08"},{"ID":9,"Gender":"男","Name":"stu09"}]}`
c1 := &Class{}
err = json.Unmarshal([]byte(str), c1)
```



**结构体标签（Tag）**

Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 

Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：

```
    `key1:"value1" key2:"value2"`
```

例如我们为Student结构体的每个字段定义json序列化时使用的Tag：

```go
//Student 学生
type Student struct {
    ID     int    `json:"id"` //通过指定tag实现json序列化该字段时的key
    Gender string //json序列化是默认使用字段名作为key
    name   string //私有不能被json包访问
}
```



## 接口 interface

在Go语言中**接口是一种类型**，一种抽象的类型，是一组method的集合，是duck-type programming的一种体现。

```go
type Sayer interface {
    say()
}

type dog struct {}

type cat struct {}

// dog实现了Sayer接口
func (d dog) say() {
    fmt.Println("汪汪汪")
}

// cat实现了Sayer接口
func (c cat) say() {
    fmt.Println("喵喵喵")
}
```

接口类型变量能够存储所有实现了该接口的实例。 例如上面的示例中，Sayer类型的变量能够存储dog和cat类型的变量。

```go
func main() {
    var x Sayer // 声明一个Sayer类型的变量x
    a := cat{}  // 实例化一个cat
    b := dog{}  // 实例化一个dog
    x = a       // 可以把cat实例直接赋值给x
    x.say()     // 喵喵喵
    x = b       // 可以把dog实例直接赋值给x
    x.say()     // 汪汪汪
}
```



**值接收者 & 指针接收者 实现接口**

```go
// 值接收者
func (d dog) say() {
    fmt.Println("汪汪汪")
}
var x Sayer
a := dog{}
b := &dog{}
x = a // ok
x = b // ok

// 指针接收者
func (d *dog) say() {
    fmt.Println("汪汪汪")
}
var x Sayer
a := dog{}
b := &dog{}
x = a // not ok
x = b // ok
```









# I / O

占位符

| 占位符 | 说明                               |
| ------ | ---------------------------------- |
| %v     | 值的默认格式表示                   |
| %+v    | 类似%v，但输出结构体时会添加字段名 |
| %#v    | 值的Go语法表示                     |
| %T     | 打印值的类型                       |
| %t     | true或false                        |
| %b     | 表示为二进制                       |
| %c     | 该值对应的unicode码值              |
| %d     | 表示为十进制                       |

scan

```go
fmt.Scan(&name, &age, &married)
fmt.Scanf("1:%s 2:%d 3:%t", &name, &age, &married)
fmt.Scanln(&name, &age, &married)
```

fscan

```go
func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
```

sscan

```go
func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
```

# 异常处理

## panic

Golang 没有结构化异常，使用 panic 抛出错误，recover 捕获错误。

可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。

**panic：**

1. 假如函数F中书写了panic语句，会终止其后要执行的代码，假如函数F中存在要执行的defer函数列表，按照defer的逆序执行
3. 返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行
4. 直到 goroutine 整个退出，并报告错误

**recover：**

2. 用来控制一个 goroutine 的 panicking 行为，捕获 panic，从而影响应用的行为
2. 在defer函数中，通过recever来终止一个goroutine的panicking过程，从而恢复正常代码的执行
3. 可以获取通过panic传递的error

注意：

1. 利用recover处理panic指令，defer 必须放在 panic 之前定义，另外 recover 只有在 defer 调用的函数中才有效。否则当panic时，recover无法捕获到panic，无法防止panic扩散。
2. recover 处理异常后，逻辑并不会恢复到 panic 那个点去，函数跑到 defer 之后的那个点。
3. 多个 defer 会形成 defer 栈，后定义的 defer 语句会被最先调用。


```go
func main() {
    test()
}

func test() {
    defer func() {
        if err := recover(); err != nil {
            println(err.(string)) // 将 interface{} 转型为具体类型。
        }
    }()

    panic("panic error!")
}
// 输出结果
panic error!
```

如果需要保护代码 段，可将代码块重构成匿名函数，如此可确保后续代码被执 。

```go
package main

import "fmt"

func test(x, y int) {
    var z int

    func() {
        defer func() {
            if err := recover(); err != nil {
				z = 0
				fmt.Println(err)
			}
        }()
        z = x / y
        return
    }()

    fmt.Printf("x / y = %d\n", z)
}

func main() {
    test(2, 0)
}
// 输出
runtime error: integer divide by zero
x / y = 0
```

捕获函数 recover 只有在延迟调用内直接调用才会终止错误，否则总是返回 nil。任何未捕获的错误都会沿调用堆栈向外传递。

```go
package main

import "fmt"

func test() {
    defer func() {
        fmt.Println(recover()) //有效
    }()
    defer recover()              //无效！
    defer fmt.Println(recover()) //无效！
    defer func() {
        func() {
            println("defer inner")
            recover() //无效！
        }()
    }()

    panic("test panic")
}

func main() {
    test()
}
// 输出
defer inner
<nil>
test panic
```

## error

除用 panic 引发中断性错误外，还可返回 error 类型错误对象来表示函数调用状态。

```go
type error interface {
    Error() string
}
```

标准库 errors.New 和 fmt.Errorf 函数用于创建实现 error 接口的错误对象。通过判断错误对象实例来确定具体错误类型。

```go
package main

import (
    "errors"
    "fmt"
)

var ErrDivByZero = errors.New("division by zero")

func div(x, y int) (int, error) {
    if y == 0 {
        return 0, ErrDivByZero
    }
    return x / y, nil
}

func main() {
    defer func() {
        fmt.Println(recover())
    }()
    switch z, err := div(10, 0); err {
        case nil:
            println(z)
        case ErrDivByZero:
            panic(err)
    }
}
```

输出结果：

```
    division by zero
```

Go实现类似 try catch 的异常处理

```go
package main

import "fmt"

func Try(fun func(), handler func(interface{})) {
    defer func() {
        if err := recover(); err != nil {
            handler(err)
        }
    }()
    fun()
}

func main() {
    Try(func() {
        panic("test panic")
    }, func(err interface{}) {
        fmt.Println(err)
    })
}
```

输出结果：

```
    test panic
```

:question: 如何区别使用 panic 和 error 两种方式

惯例是——导致关键流程出现不可修复性错误的使用 panic，其他使用 error。



# 单元测试

Go语言中的测试依赖go test命令。

go test命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录内，所有以_test.go为后缀名的源代码文件都是go test测试的一部分，不会被go build编译到最终的可执行文件中。

在`*_test.go`文件中有三种类型的函数：单元测试函数、基准测试函数和示例函数。

| 类型     | 格式                  | 作用                           |
| -------- | --------------------- | ------------------------------ |
| 测试函数 | 函数名前缀为Test      | 测试程序的一些逻辑行为是否正确 |
| 基准函数 | 函数名前缀为Benchmark | 测试函数的性能                 |
| 示例函数 | 函数名前缀为Example   | 为文档提供示例文档             |

go test命令会遍历所有的 `*_test.go` 文件中符合上述命名规则的函数，然后生成一个临时的main包用于调用相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。

```sh
go test -v # 详细信息
go test -cover # 测试覆盖率（代码被测试套件覆盖的百分比）
```



## 普通测试

Golang单元测试对文件名和方法名，参数都有很严格的要求：

1. 文件名必须以 `xx_test.go` 命名
2. 方法必须是 `Test[^a-z]` 开头
3. 方法参数必须是 `t *testing.T`

```go
func TestName(t *testing.T){
    // ...
}
```

其中参数t用于报告测试失败和附加的日志信息。 testing.T 的拥有的方法如下：

```go
func (c *T) Error(args ...interface{})
func (c *T) Errorf(format string, args ...interface{})
func (c *T) Fail()
func (c *T) FailNow()
func (c *T) Failed() bool
func (c *T) Fatal(args ...interface{})
func (c *T) Fatalf(format string, args ...interface{})
func (c *T) Log(args ...interface{})
func (c *T) Logf(format string, args ...interface{})
func (c *T) Name() string
func (t *T) Parallel()
func (t *T) Run(name string, f func(t *T)) bool
func (c *T) Skip(args ...interface{})
func (c *T) SkipNow()
func (c *T) Skipf(format string, args ...interface{})
func (c *T) Skipped() bool
```

**示例1**

在【split/split.go】中定义函数

```go
func Split(s, sep string) (result []string) {
    i := strings.Index(s, sep)

    for i > -1 {
        result = append(result, s[:i])
        s = s[i+1:]
        i = strings.Index(s, sep)
    }
    result = append(result, s)
    return
}
```

在【split/split_test.go】中定义测试函数

```go
func TestSplit(t *testing.T) { // 测试函数名必须以Test开头，必须接收一个*testing.T类型参数
   // 定义一个测试用例类型
    type test struct {
        input string  
        sep   string
        want  []string // 期望的结果
    }
    // 定义一个存储测试用例的切片
    tests := []test{
        {input: "a:b:c", sep: ":", want: []string{"a", "b", "c"}},
        {input: "a:b:c", sep: ",", want: []string{"a:b:c"}},
        {input: "abcd", sep: "bc", want: []string{"a", "d"}},
        {input: "枯藤老树昏鸦", sep: "老", want: []string{"枯藤", "树昏鸦"}},
    }
    // 遍历切片，逐一执行测试用例
    for _, tc := range tests {
        got := Split(tc.input, tc.sep) // 程序输出的结果
        if !reflect.DeepEqual(got, tc.want) { // 因为slice不能比较直接，借助反射包中的方法比较
            t.Errorf("excepted:%#v, got:%#v", tc.want, got) // 测试失败输出错误提示
        }
    }
}
```



**子测试**

Go1.7+中新增了子测试，我们可以按照如下方式使用t.Run执行子测试：

```go
func TestSplit(t *testing.T) {
    type test struct { 
        input string
        sep   string
        want  []string
    }
    tests := map[string]test{ // 测试用例使用map存储
        "simple":      {input: "a:b:c", sep: ":", want: []string{"a", "b", "c"}},
        "wrong sep":   {input: "a:b:c", sep: ",", want: []string{"a:b:c"}},
        "more sep":    {input: "abcd", sep: "bc", want: []string{"a", "d"}},
        "leading sep": {input: "枯藤老树昏鸦", sep: "老", want: []string{"枯藤", "树昏鸦"}},
    }
    for name, tc := range tests {
        t.Run(name, func(t *testing.T) { // 使用t.Run()执行子测试
            got := Split(tc.input, tc.sep)
            if !reflect.DeepEqual(got, tc.want) {
                t.Errorf("excepted:%#v, got:%#v", tc.want, got)
            }
        })
    }
}
```



## 基准测试

基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：

```go
func BenchmarkName(b *testing.B){
    // ...
}
```

基准测试以Benchmark为前缀，需要一个`*testing.B`类型的参数b，基准测试必须要执行b.N次，这样的测试才有对照性，b.N的值是系统根据实际情况去调整的，从而保证测试的稳定性。 testing.B拥有的方法如下：

```go
func (c *B) Error(args ...interface{})
func (c *B) Errorf(format string, args ...interface{})
func (c *B) Fail()
func (c *B) FailNow()
func (c *B) Failed() bool
func (c *B) Fatal(args ...interface{})
func (c *B) Fatalf(format string, args ...interface{})
func (c *B) Log(args ...interface{})
func (c *B) Logf(format string, args ...interface{})
func (c *B) Name() string
func (b *B) ReportAllocs()
func (b *B) ResetTimer()
func (b *B) Run(name string, f func(b *B)) bool
func (b *B) RunParallel(body func(*PB))
func (b *B) SetBytes(n int64)
func (b *B) SetParallelism(p int)
func (c *B) Skip(args ...interface{})
func (c *B) SkipNow()
func (c *B) Skipf(format string, args ...interface{})
func (c *B) Skipped() bool
func (b *B) StartTimer()
func (b *B) StopTimer()
```

基准测试并不会默认执行，需要增加-bench参数：

```sh
go test -bench=Split
go test -bench=Split -benchmem # 内存分配的统计数据
```

**示例1**

```go
func BenchmarkSplit(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Split("枯藤老树昏鸦", "老")
    }
}
```

输出结果如下：

```
split $ go test -bench=Split
goos: darwin
goarch: amd64
pkg: github.com/pprof/studygo/code_demo/test_demo/split
BenchmarkSplit-8        10000000               203 ns/op
PASS
ok      github.com/pprof/studygo/code_demo/test_demo/split       2.255s
```

其中BenchmarkSplit-8表示对Split函数进行基准测试，数字8表示GOMAXPROCS的值，这个对于并发基准测试很重要。10000000和203ns/op表示每次调用Split函数耗时203ns，这个结果是10000000次调用的平均值。



## 示例函数

既没有参数也没有返回值。标准格式如下：

```go
func ExampleName() {
    // ...
}
```

下面的代码是我们为Split函数编写的一个示例函数：

```go
func ExampleSplit() {
    fmt.Println(split.Split("a:b:c", ":"))
    fmt.Println(split.Split("枯藤老树昏鸦", "老"))
    // Output:
    // [a b c]
    // [ 枯藤 树昏鸦]
}
```

为你的代码编写示例代码有如下三个用处：

- 示例函数能够作为文档直接使用，例如基于web的godoc中能把示例函数与对应的函数或包相关联。

- 示例函数只要包含了// Output:也是可以通过go test运行的可执行测试。

- 示例函数提供了可以直接运行的示例代码，可以直接在golang.org的godoc文档服务器上使用Go Playground运行示例代码。下图为strings.ToUpper函数在Playground的示例函数效果。

  ![示例](http://mdimg.sofice.top/202201192022860.png)

## 压力测试

压力测试用例格式同基准测试：

```go
func Benchmark_XXX(b *testing.B) { ... }
```

go test不会默认执行压力测试的函数，如果要执行压力测试需要带上参数-test.bench：

```sh
go test -test.bench=".*" # 测试全部的压力测试函数
go test -test.bench="test_name_regex" # 测试指定的的压力测试函数
```

**示例1**

```go
package gotest

import (
    "testing"
)

func Benchmark_Division(b *testing.B) {
    for i := 0; i < b.N; i++ { //use b.N for looping 
        Division(4, 5)
    }
}

func Benchmark_TimeConsumingFunction(b *testing.B) {
    b.StopTimer() //调用该函数停止压力测试的时间计数

    //做一些初始化的工作,例如读取文件数据,数据库连接之类的,
    //这样这些时间不影响我们测试函数本身的性能

    b.StartTimer() //重新开始时间
    for i := 0; i < b.N; i++ {
        Division(4, 5)
    }
}
```

执行命令`go test webbench_test.go -test.bench=".*"`，可以看到如下结果：

```
Benchmark_Division-4                   500000000          7.76 ns/op         456 B/op          14 allocs/op
Benchmark_TimeConsumingFunction-4      500000000          7.80 ns/op         224 B/op           4 allocs/op
PASS
ok      gotest    9.364s
```

上面的结果显示我们没有执行任何TestXXX的单元测试函数，显示的结果只执行了压力测试函数，第一条显示了Benchmark_Division执行了500000000次，每次的执行平均时间是7.76纳秒，第二条显示了Benchmark_TimeConsumingFunction执行了500000000，每次的平均执行时间是7.80纳秒。最后一条显示总共的执行时间





# 反射

golang实现反射是通过reflect包来实现的,  让原本是静态类型的go具备了很多动态类型语言的特征。reflect包有两个数据类型，一个是Type,一个是Value。它定义了两个重要的类型,Type和Value. Type就是定义的类型的一个数据类型，Value是值的类型,  TypeOf和ValueOf是获取Type和Value的方法。一个Type表示一个Go类型.它是一个接口,  有许多方法来区分类型以及检查它们的组成部分, 例如一个结构体的成员或一个函数的参数等. 唯一能反映 reflect.Type  实现的是接口的类型描述信息,也正是这个实体标识了接口值的动态类型.



**反射定律一：反射可以将“接口类型变量”转换为“反射类型对象”**

TypeOf

```go
// TypeOf返回表示i的动态类型的反射Type。如果i是nil接口值，则TypeOf返回nil。
func TypeOf(i interface{}) Type
```

ValueOf

```go
// ValueOf返回一个新的Value，初始化为存储在接口i中的具体值。 ValueOf（nil）返回零值
func ValueOf(i interface{}) Value
```

可以使用reflect.ValueOf和reflect.TypeOf将接口类型变量分别转换为反射类型：

```go
var p int = 10

v1 := reflect.ValueOf(p) //返回Value类型对象，值为10
t1 := reflect.TypeOf(p)//返回Type类型对象，值为int

v2 := reflect.ValueOf(&p)//返回Value类型对象，值为&p，变量p的地址
t2 := reflect.TypeOf(&p)//返回Type类型对象，值为*int
```



**反射定律二：反射可以将“反射类型对象”转换为“接口类型变量”**

reflect.ValueOf 的逆操作是 reflect.Value.Interface方法.它返回一个 interface{}类型，装载着与reflect.Value相同的具体值

```go
v3 := v2.Interface().(*int) // 得到p的指针
```



**反射定律三：如果要修改反射类型对象，其值必须是“addressable”**

可以通过CanSet函数可以判定反射对象是否可以修改

```go
// CanSet报告是否可以更改v的值.仅当值可寻址且未通过使用未导出的struct字段获取时，才能更改值。如果CanSet返回false，则调用Set或任何特定于类型的setter（例如，SetBool，SetInt）将会发生混乱。
func (v Value) CanSet() bool
```

```go
// Elem返回接口v包含的值或指针v指向的值。如果v的Kind不是Interface或Ptr，它会发生恐慌。如果v为nil，则返回零值。
func (v Value) Elem() Value
```

修改值

```go
var p float64 = 3.4
v1 := reflect.ValueOf(&p)
if v1.Kind() == reflect.Ptr && !v1.Elem().CanSet() { //判断是否为指针类型,元素是否可以修改　　　
    fmt.Println("cannot set value")　　　
    return
} else {　　　
    v1 = v1.Elem() //实际取得的对象　　　
    fmt.Println("CanSet return bool:", v1.CanSet())
}
v1.SetFloat(6.1)
fmt.Println("p=",p)
```

解析类

```go
type User struct {     
    Name   string `json:"name"`     
    Gender string `json:"gender"`     
    Age    int    `json:"age"`
}
func main()  {     
    types := reflect.TypeOf(&User{}).Elem()     
    value := reflect.ValueOf(&User{}).Elem()     
    fmt.Println("values Numfield:",value.NumField())     
    for i:=0;i<types.NumField();i++{    
        m := types.Field(i).Tag.Get("json")    
        fmt.Println(m)     
    }
}
```





# 正则表达式

- re := regexp.MustCompile(reStr)，传入正则表达式，得到正则表达式对象
- ret := re.FindAllStringSubmatch(srcStr,-1)：用正则对象，获取页面页面，srcStr是页面内容，-1代表取全部



```go
reQQEmail = `(\d+)@qq.com`

re := regexp.MustCompile(reQQEmail)
results := re.FindAllStringSubmatch(pageStr, -1)

for _, result := range results {
    fmt.Println("email:", result[0])
    fmt.Println("qq:", result[1])
}
```





# 爬虫

**模拟浏览器头：**User-Agent 可以用 [fake-useragent](https://github.com/EDDYCJY/fake-useragent) 这个项目来随机生成 UA 头😄

