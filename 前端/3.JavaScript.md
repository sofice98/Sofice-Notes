# JavaScript 基础

## 引用js脚本

1.外链式

```html
<script type="text/javascript" src="js/src.js"></script>
```

2.嵌入式

```html
<script type="text/javascript">
	document.write("<h1>HTML5 + CSS + JS --- head标签</h1>");
</script>
```

**脚本阻塞**

HTML 元素是按其在页面中出现的次序调用的，如果用 JavaScript 来管理页面上的元素（更精确的说法是使用 文档对象模型 DOM），若 JavaScript 加载于欲操作的 HTML 元素之前，则代码将出错。

- `async`：不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。当页面的脚本之间彼此独立，且不依赖于本页面的其它任何脚本时，`async` 是最理想的选择。
- `defer` ：脚本将按照在页面中出现的顺序加载和运行



## JavaScript，API和其他JavaScript工具之间的关系

- **JavaScript**：一种**内置于浏览器**的高级脚本语言，您可以用来实现Web页面/应用中的功能。注意JavaScript也可用于其他象[Node](https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/Introduction)这样的的编程环境。
- **客户端API** ：内置于浏览器的结构程序，位于JavaScript语言顶部，使您可以更容易的实现功能。
- **第三方API** ：置于第三方普通的结构程序（例如Twitter，Facebook），使您可以在自己的Web页面中使用那些平台的某些功能（例如在您的Web页面显示最新的Tweets）。通常来说，这首先需要您通过一个 \<script> 元素连接到第三方服务器所开放的JavaScript库。
- **JavaScript库**：通常是包含具有特定功能的一个或多个JavaScript文件，把这些文件关联到您的Web页以快速或授权编写常见的功能。例如包含jQuery和Mootools
- **JavaScript框架**：从库开始的下一步，JavaScript框架视图把HTML、CSS、JavaScript和其他安装的技术打包在一起，然后用来从头编写一个完整的Web应用。



## web浏览器的重要部分

下面的图表表示了直接出现在web页面视图中的浏览器的主要部分：

![img](http://mdimg.sofice.top/202203031531273.png)

- navigator：表示浏览器存在于web上的状态和标识（即用户代理）。在JavaScript中，用[`Navigator`](https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator)来表示。你可以用这个对象获取一些信息，比如来自用户摄像头的地理信息、用户偏爱的语言、多媒体流等等。
- window：载入浏览器的标签，在JavaScript中用[`Window`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window)对象来表示，使用这个对象的可用方法，你可以返回窗口的大小（参见[`Window.innerWidth`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/innerWidth)和[`Window.innerHeight`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/innerHeight)），操作载入窗口的文档，存储客户端上文档的特殊数据（例如使用本地数据库或其他存储设备），为当前窗口绑定[event handler](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#a_series_of_fortunate_events)，等等。
- document（在浏览器中用DOM表示）：载入窗口的实际页面，在JavaScript中用[`Document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document) 对象表示，你可以用这个对象来返回和操作文档中HTML和CSS上的信息。例如获取DOM中一个元素的引用，修改其文本内容，并应用新的样式，创建新的元素并添加为当前元素的子元素，甚至把他们一起删除。



## 文档对象模型 DOM

在浏览器标签中当前载入的文档用文档对象模型来表示。这是一个由浏览器生成的“树结构”，使编程语言可以很容易的访问HTML结构







# 变量

```javascript
let randomNumber = Math.floor(Math.random() * 100) + 1;
```



## var 与 let 的区别

由于变量提升（自动将声明放在使用前），var可以在初始化后声明，但这种设计令人困惑。

let不会变量提升，必须先声明再使用。



## 变量类型

**基本数据类型**

基本数据类型是指存放在栈中的简单数据段，数据大小确定，内存空间大小可以分配，它们是直接按值存放的，所以可以直接按值访问

| 类型      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| Number    | 数字，包含整数和浮点数。NaN为数字类型，非法运算符返回NaN，NaN不等于自身。isNaN判断是否为数字。 |
| String    | 字符串                                                       |
| Boolean   | true或false。【null，undefined，NaN，0，‘’】转换为false，【非空对象，非0，非空字符串】转换为true |
| null      |                                                              |
| undefined |                                                              |
| Symbol    |                                                              |

**引用数据类型**

| 类型   | 说明                                   |
| ------ | -------------------------------------- |
| Array  | ['Chris', 'Bob', 'Jim']                |
| Object | { name : 'Spot', breed : 'Dalmatian' } |

**运算符**

- 乘方：**

- 有自增自减



常用属性：

- 长度：length



# 字符串

字符串的值是不可变的，所以很多的字符串的`api`不会改变原字符串值



其他转字符串：

```js
let my = 123;
// let my = ['Chris', 'Bob', 'Jim'];
let myString = my.toString();
```

字符串转其他：

```js
let my = "true";
console.log(Boolean(my));
let my = "123";
console.log(Number(my));
```



| 方法                        | 说明         |
| --------------------------- | ------------ |
| length                      | 长度         |
| indexOf('zilla')            | 子串起始位置 |
| slice(0,3)                  | 提取子串     |
| toLowerCase / toUpperCase() | 转换大小写   |
| replace('moz','van')        | 替换         |



**数字前添0**

需要添n个0，在前面添n-1个，再截取后n个

```js
('000000000'+num).slice(-10)
```



# 数组

| 方法                                                | 说明                                                         |
| --------------------------------------------------- | ------------------------------------------------------------ |
| push('Bradford', 'Brighton') / unshift('Edinburgh') | 添加，返回数组的新长度，尾部 / 头部，修改原数组              |
| pop() / shift()                                     | 删除，返回已删除的项目，尾部 / 头部，修改原数组              |
| join(',')                                           | 设置连接符，转为字符串                                       |
| concat                                              | 连接多个元素，返回新数组                                     |
| slice                                               | 截取，返回新数组                                             |
| includes                                            | 是否包含某个值                                               |
| sort((a, b) => a - b)                               | 升序排序，修改原数组                                         |
| reverse                                             | 反转                                                         |
| fill(val) / fill(val, start, end)                   | 填数                                                         |
| every(function)                                     | 判断所有元素是否都满足条件                                   |
| forEach(function(val, index, arr))                  | 遍历，回调参数（元素值，下标，数组），没有返回值，不修改数组 |
| map(function(val, index, arr))                      | 同上，返回新数组，不修改                                     |

Array方法

| 方法                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| Array(n)              | 创建长度为n的空数组                                          |
| Array.from(arr)       | 把一个可以遍历的对象（内部有Symbol.iterator迭代器）转化为真正的数组 |
| Array.of(...elements) | 创建一个具有可变数量参数的新的数组实例                       |
|                       |                                                              |
|                       |                                                              |





# 函数

```javascript
//普通函数
function add(a,b){
    console.log(a+b);
}
add(3,4)//使用
// 匿名函数
myButton.onclick = function() {
  alert('hello');
}
//表达式函数
var add = function(a,b){
    console.log(a+b);
}
//回调函数
function callback(fun,a,b){
	fun(a,b);
}
callback(add,3,4);//使用回调函数（不加括号）
callback(function(a,b){//使用匿名函数参数的回调函数,此时不需定义add
    console.log(a+b);
},3,4);
callback((a,b)=>{//ES6
    console.log(a+b);
},3,4);
```



# 事件

当我们定义了一个用来回应事件被激发的代码块的时候，我们说我们**给一个监听器注册了一个事件处理器**

```js
const btn = document.querySelector('button');

// 1.匿名函数
btn.onclick = function() {
  const rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')';
  document.body.style.backgroundColor = rndCol;
}

// 2.具名函数
function bgChange() {
  const rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')';
  document.body.style.backgroundColor = rndCol;
}
btn.onclick = bgChange;

// 3.addEventListener & removeEventListener
// 大型的、复杂的项目中高效地添加、清除事件处理器
btn.addEventListener('click', bgChange);
btn.removeEventListener('click', bgChange);
// 给一个监听器注册多个处理器
myElement.onclick = functionA; // no，会覆盖
myElement.onclick = functionB;
myElement.addEventListener('click', functionA); // yes
myElement.addEventListener('click', functionB);
```

⛔**不要使用行内事件处理器**：难以管理，效率低下，文档很难解析。最好的办法是只在一块地方写 JavaScript 代码。



**事件对象**

事件处理器的参数

```js
function bgChange(e) {
  const rndCol = 'rgb(' + random(255) + ',' + random(255) + ',' + random(255) + ')';
  e.target.style.backgroundColor = rndCol;
  console.log(e);
}

btn.addEventListener('click', bgChange);
```

```javascript
var events=require('events')
var myEmitter = new events.EventEmitter();

myEmitter.on('someEvent',function(message){//定义事件someEvent
	console.log(message);
})
myEmitter.emit('someEvent','the event was emitted')//触发事件someEvent
```



**阻止默认行为**

```js
form.onsubmit = function(e) {
  if (fname.value === '' || lname.value === '') {
    e.preventDefault(); // 阻止表单提交
    para.textContent = 'You need to fill in both names!';
  }
}
```



## **事件冒泡及捕获**

当一个事件发生在具有父元素的元素上(例如，在我们的例子中是`<video>`元素)时，现代浏览器运行两个不同的阶段 - 捕获阶段和冒泡阶段。 在捕获阶段：

- 浏览器检查元素的最外层祖先`<html>`，是否在捕获阶段中注册了一个`onclick`事件处理程序，如果是，则运行它。
- 然后，它移动到`<html>`中单击元素的下一个祖先元素，并执行相同的操作，然后是单击元素再下一个祖先元素，依此类推，直到到达实际点击的元素。

在冒泡阶段，恰恰相反:

- 浏览器检查实际点击的元素是否在冒泡阶段中注册了一个`onclick`事件处理程序，如果是，则运行它
- 然后它移动到下一个直接的祖先元素，并做同样的事情，然后是下一个，等等，直到它到达`<html>`元素。

**在现代浏览器中，默认情况下，所有事件处理程序都在冒泡阶段进行注册。**

![https://media.prod.mdn.mozit.cloud/attachments/2016/10/07/14075/1805b5a6f5ec0cd7f64f9d645f144510/bubbling-capturing.png](http://mdimg.sofice.top/202203011111997.png)

**阻止冒泡传递**

```js
video.onclick = function(e) {
  e.stopPropagation();
  video.play();
};
```

 

## 事件委托

冒泡还允许我们利用事件委托——这个概念依赖于这样一个事实,如果你想要在大量子元素中单击任何一个都可以运行一段代码，您可以将事件监听器设置在其父节点上，并让子节点上发生的事件冒泡到父节点上，而不是每个子节点单独设置事件监听器。

一个很好的例子是一系列列表项，如果你想让每个列表项被点击时弹出一条信息，您可以将`click`单击事件监听器设置在父元素`<ul>`上，这样事件就会从列表项冒泡到其父元素`<ul>`上。



# 对象

**构造函数**：大写开头

```js
function Person(name) {
  this.name = name;
  this.greeting = function() {
    alert('Hi! I\'m ' + this.name + '.');
  };
}
```

**Object()构造函数**

```js
var person1 = new Object();
person1.name = 'Chris';
person1['age'] = 38;
person1.greeting = function() {
  alert('Hi! I\'m ' + this.name + '.');
}

// 或
var person1 = new Object({
  name : 'Chris',
  age : 38,
  greeting : function() {
    alert('Hi! I\'m ' + this.name + '.');
  }
});
```

**create()方法**

从指定原型对象创建一个新的对象

    var person2 = Object.create(person1);
**constructor 属性**

每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。**没有原始构造器的引用**时会很方便。

```js
person1.constructor // 返回 Person() 构造器
```





## 原型链

JavaScript 只有一种结构：对象。每个实例对象（object）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（**prototype**）。该原型对象也有一个自己的原型对象（__proto__），层层向上直到一个对象的原型对象为 `null`。根据定义，`null` 没有原型，并作为这个**原型链**中的最后一个环节。

几乎所有 JavaScript 中的对象都是位于原型链顶端的 [`Object`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object) 的实例。

JavaScript 是动态的，本身不提供一个 `class` 的实现。即便是在 ES6 中引入了 `class` 关键字，但那也只是语法糖，JavaScript 仍然是基于原型的。

⭐原型链中的方法和属性**没有**被复制到其他对象——它们被访问需要通过“原型链”的方式。

⭐为什么要使用原型：节省资源，方法是共用的



这几个要点是理解原型的关键：

1、所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）。

2、所有的引用类型都有一个’_ _ proto_ _'属性(也叫隐式原型，它是一个普通的对象)。

3、所有的函数都有一个’prototype’属性(这也叫显式原型，它也是一个普通的对象)。

4、所有引用类型，它的’_ _ proto_ _'属性指向它的构造函数的’prototype’属性。

5、当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _'属性(也就是它的构造函数的’prototype’属性)中去寻找。

```js
// 构造函数
function Foo(name,age){
    this.name=name;
    this.age=age;
}
Object.prototype.toString=function(){
    //this是什么要看执行的时候谁调用了这个函数。
    console.log("I'm "+this.name+" And I'm "+this.age);
}
var fn=new Foo('小明',19);
fn.toString(); //I'm 小明 And I'm 19
console.log(fn.toString===Foo.prototype.__proto__.toString); //true

console.log(fn.__proto__ ===Foo.prototype)//true
console.log(Foo.prototype.__proto__===Object.prototype)//true
console.log(Object.prototype.__proto__===null)//true

```

![image-20220301155835627](http://mdimg.sofice.top/202203011558732.png)

在使用原型的时候，一般推荐将需要扩展的方法写在**构造函数的prototype属性**中，避免写在_ _ proto _ _属性里面。



## 继承

```js
function Teacher(first, last, age, gender, interests, subject) {
  Person.call(this, first, last, age, gender, interests); // 调用父原型构造函数

  this.subject = subject;
}
```



## Class

ES6 引入了class关键字。

在底层，你的类被转换成原型继承模型——这只是语法糖

```js
class Person {
  constructor(first, last, age, gender, interests) {
    this.name = {
      first,
      last
    };
    this.age = age;
    this.gender = gender;
    this.interests = interests;
  }

  greeting() {
    console.log(`Hi! I'm ${this.name.first}`);
  };

  farewell() {
    console.log(`${this.name.first} has left the building. Bye for now!`);
  };
    
  get subject() {
    return this._subject;
  }

  set subject(newSubject) {
    this._subject = newSubject;
  }
}
```

**继承**

```js
class Teacher extends Person {
  constructor(first, last, age, gender, interests, subject, grade) {
    super(first, last, age, gender, interests);

    // subject and grade are specific to Teacher
    this.subject = subject;
    this.grade = grade;
  }
}

```









# 作用域

假设有一个HTML文件，它调用两个外部JavaScript文件，并且它们都有一个使用相同名称定义的变量和函数：

例如，假设您有一个HTML文件，它调用两个外部JavaScript文件，并且它们都有一个使用相同名称定义的变量和函数：

```
<!-- Excerpt from my HTML -->
<script src="first.js"></script>
<script src="second.js"></script>
<script>
  greeting();
</script>

// first.js
let name = 'Chris';
function greeting() {
  alert('Hello ' + name + ': welcome to our company.');
}

// second.js
let name = 'Zaptec';
function greeting() {
  alert('Our company is called ' + name + '.');
}
```

这两个函数都使用 `greeting()` 形式调用，但是你只能访问到 first.js 文件的`greeting()`函数（第二个文件被忽视了）。另外，第二次尝试使用 `let` 关键字定义 `name` 变量导致了一个错误。



# I / O

**console**

```javascript
console.log("hello")//输出
var json1=[			//json对象
		{name:"sizhanyu",age:20},
		{name:"yezhuangzhuang",age:21}
	]
console.dir(js)		//输出一个对象所有属性和方法
```



‘



# 模块

```javascript
//主文件 app.js
var stuff=require('./count.js')//导入模块
console.log(stuff.add(3,4));//取出对象
console.log(stuff.pi);
```

```javascript
//模块文件 count.js,与主文件在同一目录下
var add=(a,b)=>{
	return 'the sum is '+(a+b);
}
var pi=3.14;
module.exports={//导出对象
	add:add,//外部名字：内部名字
	pi:pi,
}
```







# Json

json转对象

```js
var superHeroes = JSON.parse(superHeroesText); 
```

对象转json

```js
var myString = JSON.stringify(myJSON);
```



# 异步

JavaScript 传统上是单线程的。即使有多个内核，也只能在单一线程上运行多个任务，此线程称为主线程（**main thread**）。

通过 [Web workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API) 可以把一些任务交给一个名为worker的单独的线程，这样就可以同时运行多个JavaScript代码块。一般来说，用一个worker来运行一个耗时的任务，主线程就可以处理用户的交互（避免了阻塞）



## 延迟执行和重复执行

**1.setTimeout()**

在指定的时间后执行一段特定代码

```js
let myGreeting = setTimeout(function() {
  alert('Hello, Mr. Universe!');
}, 200)
```

`setTimeout()` 返回一个标志符变量用来引用这个间隔，可以稍后用来取消这个超时任务

**传递参数给setTimeout()** 

```js
function sayHi(who) {
  alert('Hello ' + who + '!');
}
let myGreeting = setTimeout(sayHi, 2000, 'Mr. Universe');
```

**清除超时**

```js
clearTimeout(myGreeting);
```



**2.setInterval()**

重复执行

```js
function displayTime() {
   let date = new Date();
   let time = date.toLocaleTimeString();
   document.getElementById('demo').textContent = time;
}

const createClock = setInterval(displayTime, 1000);
```

`setInterval()` 返回一个确定的值，稍后你可以用它来取消间隔任务。

**清除intervals**

```js
clearInterval(myInterval);
```



**3.requestAnimationFrame()**

`requestAnimationFrame()` 是一个专门的循环函数，旨在浏览器中高效运行动画。它基本上是现代版本的`setInterval()` —— 它在浏览器重新加载显示内容之前执行指定的代码块，从而允许动画以适当的帧速率运行，不管其运行的环境如何。

```js
function draw() {
   // Drawing code goes here
   requestAnimationFrame(draw);
}

draw();
```

**包括时间戳**

传递给 `requestAnimationFrame()` 函数的实际回调也可以被赋予一个参数（一个时间戳值），表示自 `requestAnimationFrame()` 开始运行以来的时间。这是很有用的，因为它允许您在特定的时间以恒定的速度运行，而不管您的设备有多快或多慢。您将使用的一般模式如下所示：

```js
let startTime = null;

function draw(timestamp) {
    if(!startTime) {
      startTime = timestamp;
    }

   currentTime = timestamp - startTime;

   // Do something based on current time

   requestAnimationFrame(draw);
}

draw();
```

**撤销requestAnimationFrame()**

```js
cancelAnimationFrame(rAF);
```





## Promises

**异步回调**

我们来谈谈订购披萨作为类比。为了使你的订单成功，你必须按顺序执行，不按顺序执行或上一步没完成就执行下一步是不会成功的：

1. 选择配料。如果你是优柔寡断，这可能需要一段时间，如果你无法下定决心或者决定换咖喱，可能会失败。
2. 下订单。返回比萨饼可能需要一段时间，如果餐厅没有烹饪所需的配料，可能会失败。
3. 然后你收集你的披萨吃。如果你忘记了自己的钱包，那么这可能会失败，所以无法支付比萨饼的费用！

对于旧式[callbacks](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing#callbacks)，上述功能的伪代码表示可能如下所示：

```js
chooseToppings(function(toppings) {
  placeOrder(toppings, function(order) {
    collectOrder(order, function(pizza) {
      eatPizza(pizza);
    }, failureCallback);
  }, failureCallback);
}, failureCallback);
```

异步回调的缺陷：

- 嵌套回调可能很麻烦且难以阅读（即“回调地狱”）
- 每层嵌套都需要故障回调，而使用promises，您只需使用一个`.catch（）`代码块来处理整个链的错误。
- 异步回调不是很优雅。
- Promise回调总是按照它们放在事件队列中的严格顺序调用;异步回调不是。
- 当传入到一个第三方库时，异步回调对函数如何执行失去完全控制。



**Promise** 

Promises是一个对象，代表操作的中间状态（**pending**，待定）。虽然 Promise 并不保证操作在何时完成并返回结果，但是它保证当结果可用时（fullfilled），你的代码能正确处理结果，当结果不可用时，你的代码同样会被执行，来优雅的处理错误。

```js
myPromise
.then(response => {
  doSomething(response);
})
.catch(e => {
  returnError(e);
})
.finally(() => {
  runFinalCode();
});
```

Promises使得上面的情况更容易编写，解析和运行。如果我们使用异步promises代表上面的伪代码，我们最终会得到这样的结果：

```js
chooseToppings()
.then(function(toppings) {
  return placeOrder(toppings);
})
.then(function(order) {
  return collectOrder(order);
})
.then(function(pizza) {
  eatPizza(pizza);
})
.catch(failureCallback);
```

只需要一个`.catch()`块来处理所有错误，它不会阻塞主线程，并保证每个操作在运行之前等待先前的操作完成。

使用箭头函数，你可以进一步简化代码：

```js
chooseToppings()
.then(toppings => placeOrder(toppings))
.then(order => collectOrder(order))
.then(pizza => eatPizza(pizza))
.catch(failureCallback);
```

最基本的，promise与事件监听器类似，但有一些差异：

- 一个promise只能成功或失败一次。它不能成功或失败两次，并且一旦操作完成，它就无法从成功切换到失败，反之亦然。
- 如果promise成功或失败并且你稍后添加成功/失败回调，则将调用正确的回调，即使事件发生在较早的时间。



**例：**fetch用来下载一张图片，返回response对象；判断是否成功下载，成功下载返回blob对象；将blob对象解析放入image；catch失败的情况。

```js
fetch('coffee.jpg')
.then(response => {
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  } else {
    return response.blob();
  }
})
.then(myBlob => {
  let objectURL = URL.createObjectURL(myBlob);
  let image = document.createElement('img');
  image.src = objectURL;
  document.body.appendChild(image);
})
.catch(e => {
  console.log('There has been a problem with your fetch operation: ' + e.message);
});
```



**响应多个Promises**

如果它们都实现，那么数组中的结果将作为参数传递给`.then()`块中的执行器函数。如果传递给`Promise.all()`的任何一个 promise 拒绝，整个块将拒绝。

```js
Promise.all([a, b, c]).then(values => {
  ...
});
```



**自定义Promise**

成功resolve，失败reject。reject会被 catch 到

```js
function timeoutPromise(message, interval) {
    return new Promise((resolve, reject) => {
        if (message === '' || typeof message !== 'string') {
            reject('Message is empty or not a string');
        } else if (interval < 0 || typeof interval !== 'number') {
            reject('Interval is negative or not a number');
        } else {
            setTimeout(function () {
                resolve(message);
            }, interval);
        }
    });
};
```



## async和await

ES8里新增的基于promises的语法糖，使异步代码更易于编写和阅读。



**异步函数 async**

将函数变为promise

```js
// 定义异步函数的三种方法
async function hello() { return "Hello" }; 
let hello = async function() { return "Hello" };
let hello = async () => { return "Hello" };

hello(); // 返回promise
hello().then((value) => console.log(value)) // 使用promise
```

**异步promise await**

**await 只在异步函数里面才起作用**。它可以放在任何异步的，基于 promise 的函数之前。它会阻塞其后的代码，直到promise完成，然后返回结果值。在暂停的同时，其他正在等待执行的代码就有机会执行了。

```js
async function hello() {
  return greeting = await Promise.resolve("Hello");
};

hello().then(alert);
```



**例：**fetch用来下载一张图片，返回response对象；判断是否成功下载，成功下载返回blob对象；将blob对象解析放入image；catch失败的情况。

```js
async function myFetch(url) {
    let response = await fetch(url);
    return await response.blob();
}

myFetch('https://img2.baidu.com/it/u=73016861,4243186123&fm=253&fmt=auto&app=138&f=PNG?w=499&h=253').then((blob) => {
    let objectURL = URL.createObjectURL(blob);
    let image = document.createElement('img');
    image.src = objectURL;
    document.body.appendChild(image);
}).catch(e => {
    console.log('There has been a problem with your fetch operation: ' + e.message);
});
```



**Promise.all()**

```js
let values = await Promise.all([coffee, tea, description]);
```



**async/await的缺陷**

`await` 关键字会阻塞其后的代码，直到promise完成，就像执行同步操作一样。它确实可以允许其他任务在此期间继续运行，但您自己的代码被阻塞。

这意味着您的代码可能会因为大量`await`的promises相继发生而变慢。每个`await`都会等待前一个完成，而你实际想要的是所有的这些promises同时开始处理（就像我们没有使用`async/await`时那样）。

有一种模式可以缓解这个问题——通过将 `Promise` 对象存储在变量中来同时开始它们，然后等待它们全部执行完毕。

```js
// 改进前
async function timeTest() {
  await timeoutPromise(3000);
  await timeoutPromise(3000);
  await timeoutPromise(3000);
}

// 改进后
async function timeTest() {
  const timeoutPromise1 = timeoutPromise(3000);
  const timeoutPromise2 = timeoutPromise(3000);
  const timeoutPromise3 = timeoutPromise(3000);

  await timeoutPromise1;
  await timeoutPromise2;
  await timeoutPromise3;
}
```



**Async/await 的类方法**

最后值得一提的是，我们可以在类/对象方法前面添加`async`，以使它们返回promises，并`await`它们内部的promises。

```js
class Person {
  constructor(first, last, age, gender, interests) {
    this.name = {
      first,
      last
    };
    this.age = age;
    this.gender = gender;
    this.interests = interests;
  }

  async greeting() {
    return await Promise.resolve(`Hi! I'm ${this.name.first}`);
  };

  farewell() {
    console.log(`${this.name.first} has left the building. Bye for now!`);
  };
}

let han = new Person('Han', 'Solo', 25, 'male', ['Smuggling']);
```

第一个实例方法可以使用如下：

```js
han.greeting().then(console.log);
```





# ES 6 新特性

1. 箭头函数

   更简短，并且不需要this。函数不会创建自己的this，它只会从自己的作用域链的上一层继承this

   箭头函数不能用作构造器。

   在一个简写体中，只需要一个表达式，并附加一个隐式的返回值。在块体中，必须使用明确的`return`语句。

   ```js
   // 简写函数 省略return
   var func = x => x * x;
   
   // 常规编写 明确的返回值
   var func = (x, y) => { return x + y; };
   
   // 返回对象要用()包裹
   var func = () => ({foo: 1});
   ```



















