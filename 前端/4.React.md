# React 基础

React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。



# JSX

JSX是一个 JavaScript 的语法扩展。

React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。

React 并没有采用将*标记与逻辑进行分离到不同文件*这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现[*关注点分离*](https://en.wikipedia.org/wiki/Separation_of_concerns)。



在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式。例如，2 + 2，user.firstName 或 formatName(user) 都是有效的 JavaScript 表达式。Babel 会把 JSX 转译成一个名为 `React.createElement()` 函数调用。

```jsx
const name = 'Josh Perez';
const element = <h1>Hello, {name}</h1>;
ReactDOM.render(
  element,
  document.getElementById('root')
);
```

使用大括号或引号指定属性值



# 元素

元素是构成 React 应用的最小砖块。

想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 [`ReactDOM.render()`](https://react.docschina.org/docs/react-dom.html#render)：

```jsx
const element = <h1>Hello, world</h1>;
ReactDOM.render(element, document.getElementById('root'));
```

React 元素是**不可变对象**。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。

根据我们已有的知识，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 `ReactDOM.render()`

**React 只更新它需要更新的部分：**React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。

因此，考虑 **UI 在任意给定时刻的状态**，而不是随时间变化的过程，能够消灭一整类的 bug。



# 组件 & Props

组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。[详细组件 API](https://react.docschina.org/docs/react-component.html)

组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。



函数组件

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

class 组件 

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

## 渲染组件 

当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。

例如，这段代码会在页面上渲染 “Hello, Sara”：

```jsx
function Welcome(props) {  return <h1>Hello, {props.name}</h1>;
}

const element = <Welcome name="Sara" />;ReactDOM.render(
  element,
  document.getElementById('root')
);
```

⭐**组件名称必须以大写字母开头**，React 会将以小写字母开头的组件视为原生 DOM 标签。

React 非常灵活，但它也有一个严格的规则：**所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。**





## 条件渲染

```jsx
function Greeting(props) {
  const isLoggedIn = props.isLoggedIn;
  if (isLoggedIn) return <UserGreeting />; 
  else return <GuestGreeting />;
}
```

**与运算符 &&** 

```jsx
function Mailbox(props) {
  const unreadMessages = props.unreadMessages;
  return (
    <div>
      <h1>Hello!</h1>
      {unreadMessages.length > 0 &&        
        <h2>          
          You have {unreadMessages.length} unread messages.        
        </h2>      
      }    
    </div>
  );
}
```

**三目运算符**

```jsx
render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    <div>
      The user is <b>{isLoggedIn ? 'currently' : 'not'}</b> logged in.    
    </div>
  );
}
```

**阻止组件渲染** 

在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 `render` 方法直接返回 `null`，而不进行任何渲染。

 在组件的 `render` 方法中返回 `null` 并不会影响组件的生命周期。

```jsx
function WarningBanner(props) {
  if (!props.warn) {    
      return null;  
  }
  return (
    <div className="warning">
      Warning!
    </div>
  );
}
```



## 组件列表

```jsx
function ListItem(props) {
  // 这里不需要指定 key：  
  return <li>{props.value}</li>;
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) =>
    // key 应该在数组的上下文中被指定    
    <ListItem key={number.toString()} value={number} />
  );
  return <ul>{listItems}</ul>；
}

const numbers = [1, 2, 3, 4, 5];
ReactDOM.render(
  <NumberList numbers={numbers} />,
  document.getElementById('root')
);
```

**渲染多个组件** 

我们使用 Javascript 中的 [`map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) 方法来遍历 `numbers` 数组。将数组中的每个元素变成 `<li>` 标签

**key**

key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。

一个元素的 key 最好是这个元素**在这个列表中**拥有的一个独一无二的字符串，它们不需要是全局唯一的。

通常，我们使用**数据中的 id** 来作为元素的 key。

⛔当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key，但如果列表项目的顺序可能会变化，我们**不建议使用索引**来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。

⭐元素的 key 只有放在就近的数组上下文中才有意义。一个好的经验法则是：在 `map()` 方法中的元素需要设置 key 属性。

key 会传递信息给 React ，但**不会传递给你的组件**。如果你的组件中需要使用 `key` 属性的值，请用其他属性名（如 'id'属性）显式传递这个值。

JSX 允许在大括号中[嵌入任何表达式](https://react.docschina.org/docs/introducing-jsx.html#embedding-expressions-in-jsx)，所以我们可以内联 `map()` 返回的结果：

```jsx
function NumberList(props) {
  const numbers = props.numbers;
  return (
    <ul>
      {numbers.map((number) =>        
        <ListItem key={number.toString()}                  
          value={number} />      
      )}    
    </ul>
  );
}
```



## 受控组件 

使 React 的 state 成为“唯一数据源”，并且渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。

```jsx
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```

由于在表单元素上设置了 `value` 属性，因此显示的值将始终为 `this.state.value`，这使得 React 的 state 成为唯一数据源。由于 `handlechange` 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。



# State & 生命周期

**render()：**在class组件中，每次组件更新时 `render` 方法都会被调用。



**state：**State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。使用 `this.setState()` 来时刻更新 组件 state（直接更改无效`this.state.comment = 'Hello';` ）。

**State 的更新可能是异步的：**出于性能考虑，React 可能会把多个 `setState()` 调用合并成一个调用。可以让 `setState()` 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：

```js
this.setState((state, props) => ({
  counter: state.counter + props.increment
}));
```

**数据是向下流动的 ：**不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，但可以选择把它的 state 作为 props 向下传递到它的子组件中



**生命周期：**在具有许多组件的应用程序中，当组件被销毁时释放所占用的资源是非常重要的。

- **挂载（mount）：**当组件第一次被渲染到 DOM 中的时候，就为其设置一个计时器

- **卸载（unmount）：**同时，当 DOM 中组件被删除的时候，应该清除计时器

我们可以为 class 组件声明一些特殊的方法，当组件挂载或卸载时就会去执行这些**生命周期方法**：

```jsx
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(      
        () => this.tick(),
        1000    
    );  
  }
  componentWillUnmount() {
    clearInterval(this.timerID);  
  }
  tick() {    
      this.setState({      
          date: new Date()    
      });  
  }
  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```





# 事件处理

- React 事件的命名采用小驼峰式（camelCase），而不是纯小写。
- 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。

```jsx
function ActionLink() {
  function handleClick(e) {    
      e.preventDefault();    
      console.log('The link was clicked.');  
  }
  return (
    <a href="#" onClick={handleClick}>      
          Click me
    </a>
  );
}
```

使用 React 时，你一般不需要使用 `addEventListener` 为已创建的 DOM 元素添加监听器。事实上，你只需要在该元素初始渲染的时候添加监听器即可。



使用 [ES6 class](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes) 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。

```jsx
// 1.绑定函数
// 在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined。
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};
    // 为了在回调中使用 `this`，这个绑定是必不可少的    
    this.handleClick = this.handleClick.bind(this);  
  }
  handleClick() {    
    this.setState(state => ({      
      isToggleOn: !state.isToggleOn    
    }));  
  }
  render() {
    return (
      <button onClick={this.handleClick}>        
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}
// 2.public class fields
// 注意: 这是 *实验性* 语法。
class LoggingButton extends React.Component {  
  // 此语法确保 `handleClick` 内的 `this` 已被绑定。
  handleClick = () => {    
    console.log('this is:', this);  
  }
  render() {
    return (
      <button onClick={this.handleClick}>
        Click me
      </button>
    );
  }
}
// 3.箭头函数⛔
// 此语法问题在于每次渲染 LoggingButton 时都会创建不同的回调函数。在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。
class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this);
  }
  render() {
    // 此语法确保 `handleClick` 内的 `this` 已被绑定。  
    return (      
      <button onClick={() => this.handleClick()}>        
        Click me
      </button>
    );
  }
}
```



