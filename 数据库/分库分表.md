# ⌛ 分库分表相关概念

---

首先要明确一点：分库分表是两回事儿，可能是光分库不分表，也可能是光分表不分库，也可能都分。

## 1. 为什么要分库分表

**分库分表是为了解决由于库、表数据量过大，而导致数据库性能持续下降的问题。**

## 2. 垂直拆分 和 水平拆分

- **垂直拆分**的意思，就是**把一个有很多字段的表给拆分成多个表（或者是多个库）上去。每个库表的结构都不一样，每个库表都包含部分字段**。

  <img src="https://gitee.com/veal98/images/raw/master/img/20201126134834.png" style="zoom:67%;" />

  一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。

- **水平拆分**的意思，就是**把一个表的数据分到多个表（或者是多个库）里去**，但是**每个库的表结构都一样**，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。

  <img src="https://gitee.com/veal98/images/raw/master/img/20201126134847.png" style="zoom:67%;" />

## 3. 分库 和 分表

- **单表数据量太大，会极大影响你的 sql 执行的性能**，到了后面你的 sql 可能就跑的很慢了。

  **分表**就是把一个表的数据放到多个表中，使得每张表的数据量在可控的范围内。

- **分库**就是将一个库的数据拆分到多个库中

|              |          分库分表前          |                  分库分表后                  |
| :----------: | :--------------------------: | :------------------------------------------: |
| 并发支撑情况 | MySQL 单机部署，扛不住高并发 |  MySQL 从单机到多机，能承受的并发增加了多倍  |
| 磁盘使用情况 |  MySQL 单机磁盘容量几乎撑满  | 拆分为多个库，数据库服务器磁盘使用率大大降低 |
| SQL 执行性能 | 单表数据量太大，SQL 越跑越慢 |     单表数据量减少，SQL 执行效率明显提升     |



# 🍹 如何将单库单表系统迁移到分库分表

---

> 🔊 原文来自 [advanced-java - 分库分表如何平滑过渡](https://doocs.gitee.io/advanced-java/#/./docs/high-concurrency/database-shard-method)

面试题：现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表**动态切换**到分库分表上？（分库分表后的平滑过渡）

## 1. 停机迁移方案

停机迁移方案很简单，大家伙儿凌晨 12 点开始运维，网站或者 app 挂个公告，说 0 点到早上 6 点进行运维，无法访问。

接着到 0 点停机，系统停掉，没有流量写入了，此时老的单库单表数据库静止了。然后你之前得写好一个**导数的一次性工具**，此时直接跑起来，然后将单库单表的数据哗哗哗读出来，写到分库分表里面去。

导数完了之后，就 ok 了，修改系统的数据库连接配置啥的，包括可能代码和 SQL 也许有修改，那你就用最新的代码，然后直接启动连到新的分库分表上去。

<img src="https://gitee.com/veal98/images/raw/master/img/20201204111940.png" style="zoom:50%;" />

## 2. 双写迁移方案

双写迁移方案是常用的一种迁移方案，比较靠谱一些，不用停机。

简单来说，就是在线上系统里面，之前所有写库（涉及增删改操作）的地方，**除了对老库增删改，新库上也执行同样的的增删改操作**，这就是所谓的**双写**，同时写俩库，老库和新库。

然后**系统部署**之后，新库数据差太远，用之前说的导数工具<u>读老库数据写进新库，写的时候要根据 `gmt_modified` 这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。简单来说，就是不允许用老数据覆盖新数据</u>。

导完一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。<u>反复循环，直到两个库每个表的数据都完全一致为止</u>。

<img src="https://gitee.com/veal98/images/raw/master/img/20201204112308.png" style="zoom:50%;" />

## 📚 References

- [分库分表如何平滑过渡？ (gitee.io)](https://doocs.gitee.io/advanced-java/#/./docs/high-concurrency/database-shard-method)